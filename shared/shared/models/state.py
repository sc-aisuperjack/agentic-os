from typing import Annotated, List, Dict, Any, Optional
from pydantic import BaseModel, Field
from operator import add

def merge_metadata(old: Dict[str, Any], new: Dict[str, Any]) -> Dict[str, Any]:
    """Reducer logic for deep-merging metadata dictionaries."""
    return {**old, **new}

class AgentMessage(BaseModel):
    """The standard message packet for the Agentic OS."""
    role: str = Field(..., description="user, assistant, system, or tool")
    content: str
    agent_id: Optional[str] = None
    model_used: Optional[str] = None
    timestamp: str = Field(default_factory=lambda: "2025-12-29T13:30:00Z")

class AgenticState(BaseModel):
    """
    The Global State Schema.
    Uses 'Annotated' with reducers to handle parallel agent updates.
    """
    # task: The original goal from the user
    task: str
    
    # history: Appends new messages instead of overwriting (Standard LangGraph Reducer)
    history: Annotated[List[AgentMessage], add] = Field(default_factory=list)
    
    # context: Shared data retrieved by RAG or generated by Strategist
    context: Annotated[Dict[str, Any], merge_metadata] = Field(default_factory=dict)
    
    # control: Internal flags for the orchestrator (next_agent, is_complete, etc.)
    next_step: Optional[str] = "router"
    is_complete: bool = False
    
    # telemetry: Tracking token usage across Gemini/GPT providers
    usage_stats: Annotated[Dict[str, int], merge_metadata] = Field(
        default_factory=lambda: {"total_tokens": 0, "calls": 0}
    )

    class Config:
        # Pydantic 2025 optimization: uses fast-path validation
        validate_assignment = True
        arbitrary_types_allowed = True